«EXTENSION java::Naming»
«EXTENSION java::ObjectMapper»
«EXTENSION java::GeneratorCommons»
«EXTENSION org::openarchitectureware::util::stdlib::io»
«EXTENSION entity::ModelProperties»
«EXTENSION java::OpenAPIFunctions»
«EXTENSION functions::Class»
«EXTENSION functions::Property»
«EXTENSION functions::AddToJSON»
«EXTENSION functions::JSONAlias»
«EXTENSION functions::SoftLink»
«EXTENSION functions::SystemProperties»
«EXTENSION functions::JEAFDeprecated»
«EXTENSION functions::Builder»
«EXTENSION functions::Jackson»
«EXTENSION jeaf::RESTFunctions»

«IMPORT uml»
«IMPORT JMM»


«DEFINE JacksonClassAnnotations(String ownerClassSuffix) FOR Class»
	«IF generateJacksonAnnotations() && this.isStereotypeApplied("BeanParam") == false»
		«IF (this.isTechnicalBaseClass() == false && this.superClass.size == 0 && this.getSubclasses().size > 0 ) ||
		     (superClass.size > 0 && superClass.first().isTechnicalBaseClass() && this.isTechnicalBaseClass() == false && this.getSubclasses().size > 0) »
		  «IF enableSemVerForJSON() == false»
		@«getJsonIgnorePropertiesFQN()»(value = "«this.getDescriminatorPropertyName()»")
		  «ENDIF»
		@«getJsonTypeInfoFQN()»(use = «getJsonTypeInfoFQN()».Id.NAME, include = «getJsonTypeInfoFQN()».As.PROPERTY, property = "«this.getDescriminatorPropertyName()»", visible = true)
		«IF this.suppressSubtypesMapping() == false»
		@«getJsonSubTypesFQN()»({
		  «EXPAND SubtypesAnnotation -»
		 })
		 «ENDIF»
		«ENDIF»
		«IF needsToImplementIdentifiable() == true»
			@«getJsonIdentityInfoFQN()»(property = "objectID", generator = «getObjectIdGeneratorsFQN()».PropertyGenerator.class)
		«ENDIF»
		«IF generateJSONAutoDetectAnnotationOnClass()»
			@«getJsonAutoDetectFQN()»(
			     fieldVisibility = «getJsonAutoDetectFQN()».Visibility.ANY,
			     getterVisibility = «getJsonAutoDetectFQN()».Visibility.NONE,
			     isGetterVisibility = «getJsonAutoDetectFQN()».Visibility.NONE,
			     setterVisibility = «getJsonAutoDetectFQN()».Visibility.NONE,
			     creatorVisibility = «getJsonAutoDetectFQN()».Visibility.ANY)
		«ENDIF»
	    «IF this.hasAddToJSONProperty() || this.hasPropertyWithBckwardCompatibility()»
	        @«getJsonPropertyOrderFQN()»(value = {
	           «FOREACH this.getAllPropertiesFromHierarchy().select(e|e.isTransient() == false && (e.isDerived == false || ( e.isDerived && e.isAddToJSON()))) AS property SEPARATOR ", "»"«property.name»"«ENDFOREACH»
	        })
	    «ENDIF»
	    «IF this.isAbstract == false && this.isOpenAPIDataType() == false && this.hasCustomSerialization() == false && this.hasTemplateParameter() == false && this.isPOJO()»
	    	«FOREACH getJacksonVersions() AS jacksonVersion»
	    	@«getJsonDeserializeFQN(jacksonVersion)»(builder = «this.fqn()»«IF this.hasGenericBuilder()»«ownerClassSuffix»«ENDIF».«this.builderImplName()».class)
	    	«ENDFOREACH»
	    «ENDIF»
		«IF enableSemVerForJSON() && this.hasTemplateParameter() && this.isPOJO()»
			@«getJsonIgnorePropertiesFQN()»(ignoreUnknown = true)
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE SubtypesAnnotation FOR Class»
	«FOREACH this.getSubclasses().typeSelect(Class).select(e|e.ignore() == false) AS subclass SEPARATOR "," »
	«IF subclass.isAbstract == false»
	@«getJsonSubTypesFQN()».Type(value = «subclass.getNearestPackage().fqn()».«subclass.name».class, name = "«subclass.getDiscriminatorValue()»")
	«ENDIF»
		«IF subclass.getSubclasses().size >0»«IF subclass.isAbstract == false»,«ENDIF»
			«EXPAND SubtypesAnnotation FOR subclass»
		«ENDIF»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE JSONAlias FOR Property»
	«IF generateJacksonAnnotations()» 
		«IF this.isStereotypeApplied("OpenAPIAliasName") == true»
			@«getJsonPropertyFQN()»("«((OpenAPIAliasName)this).openAPIPropertyName»")
		«ELSEIF this.isSoftLink() && this.hasSoftLinkSuffix() && useSoftLinkSuffixInOpenAPI() == false»
			@«getJsonPropertyFQN()»("«this.name»")
		«ENDIF»
		
		«IF this.isJSONAlias()»
		    @«getJsonAliasFQN()»({«FOREACH this.asJSONAlias().aliasNames AS aliasName SEPARATOR ", "»"«aliasName»"«ENDFOREACH»})
		«ELSEIF this.hasPredecessorProperty() && this.isQueryParamProperty() == false && this.isPathParamProperty() == false && this.isHeaderParamProperty() == false»
			@«getJsonAliasFQN()»({"«this.getPredecessorProperty().name»"})
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE GenerateModuleFactory FOR ModuleFactory -»
	«FOREACH getJacksonVersions() AS jacksonVersion»
		«FILE packagePath() + jacksonVersion.getJacksonSubpackagePath() + "/" + name + getJacksonVersionSuffix(jacksonVersion) + ".java" src_gen»
			«getFileHeader()»
			package «this.packageName()»«jacksonVersion.getJacksonSubpackage()»;
			
			«EXPAND java::Helper::GenerateAnnotations-»
			/**
			 * Factory assembles all configured serializers / deserializers into a module.
			 */
			«IF isTargetRuntimeJEAF()»
			@com.anaptecs.jeaf.json.annotations.ModuleFactory
			«ENDIF»
			public class «name»«getJacksonVersionSuffix(jacksonVersion)» «IF isTargetRuntimeJEAF()»implements com.anaptecs.jeaf.json.api.ObjectMapperModuleFactory«ENDIF» {
			«IF isTargetRuntimeJEAF()»
				«IF this.getOpenAPIDataTypes().select(e|e.generateInternalViewOfCompositeDataType()).isEmpty == false»
					«IF isTargetRuntimeJEAF() == false && hasCompositeDateTypeCustomSerialization() == false»
						/**
						 * Composite type converter is used for serialization / deserialization in case that module factory contains composite data types.
						 */
						private final com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter compositeTypeConverter;
						
						/**
						 * Initialize object.
						 * 
						 * @param pCompositeTypeConverter {@link CompositeTypeConverter} implementation that should be used to serialize /
						 * deserialize composite data types.
						 */
						public «name»( com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter pCompositeTypeConverter ) {
						  compositeTypeConverter = pCompositeTypeConverter;
						}
					«ENDIF»
				«ENDIF»
				
				/**
				 * Method creates a module that consists of all serializers / deserializers of the current package.
				 */
				@Override
				public «getJacksonModuleFQN(jacksonVersion)» createModule( ) {
					// Create module for serializers / deserializers that are located in this package
					«getSimpleModuleFQN(jacksonVersion)» lModule = new «getSimpleModuleFQN(jacksonVersion)»(«this.getNearestPackage().fqn()»«jacksonVersion.getJacksonSubpackage()».«name»«getJacksonVersionSuffix(jacksonVersion)».class.getName());
					
					// Add serializers and deserializers for datatypes				
					«FOREACH this.getOpenAPIDataTypes() AS datatype»
						«IF datatype.isStereotypeApplied("Ignore") == false»
							«IF datatype.generateInternalViewOfCompositeDataType() && isTargetRuntimeJEAF()== false && datatype.hasCompositeDateTypeCustomSerialization() == false»
								lModule.addSerializer(«datatype.fqn()».class, new «datatype.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«datatype.name»Serializer«getJacksonVersionSuffix(jacksonVersion)»(compositeTypeConverter));
								lModule.addDeserializer(«datatype.fqn()».class, new «datatype.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«datatype.name»Deserializer«getJacksonVersionSuffix(jacksonVersion)»(compositeTypeConverter));
							«ELSE»
								lModule.addSerializer(«datatype.fqn()».class, new «datatype.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«datatype.name»Serializer«getJacksonVersionSuffix(jacksonVersion)»());
								lModule.addDeserializer(«datatype.fqn()».class, new «datatype.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«datatype.name»Deserializer«getJacksonVersionSuffix(jacksonVersion)»());
							«ENDIF»
						«ENDIF»
					«ENDFOREACH»
					
					// Add serializers and deserializers for enumerations				
					«FOREACH this.clientDependency.supplier.typeSelect(uml::Package).allOwnedElements().typeSelect(JEAFEnumeration).select(e|e.extensibleEnum && e.ignore() == false).sortBy(e|e.name) AS enum»
					lModule.addSerializer(«enum.fqn()».class, new «enum.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«enum.name»Serializer«getJacksonVersionSuffix(jacksonVersion)»());
					lModule.addDeserializer(«enum.fqn()».class, new «enum.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«enum.name»Deserializer«getJacksonVersionSuffix(jacksonVersion)»());
					«ENDFOREACH»
					
					// Return created module.
					return lModule;
				}
			«ENDIF»
				
				/**
				 * Method creates a module that consists of all serializers / deserializers for data types.
				 */
				public static «getJacksonModuleFQN(jacksonVersion)» createDataTypeSerializerModule( ) {
					// Create module for serializers / deserializers that are located in this package
					«getSimpleModuleFQN(jacksonVersion)» lModule = new «getSimpleModuleFQN(jacksonVersion)»("DataTypeSerializerModule." + «this.getNearestPackage().fqn()»«jacksonVersion.getJacksonSubpackage()».«name»«getJacksonVersionSuffix(jacksonVersion)».class.getName());
					
					// Add serializers and deserializers for data types				
					«FOREACH this.getOpenAPIDataTypes() AS datatype»
						«IF datatype.isStereotypeApplied("Ignore") == false»
							«IF datatype.generateInternalViewOfCompositeDataType() && isTargetRuntimeJEAF()== false && datatype.hasCompositeDateTypeCustomSerialization() == false»
							«ELSE»
								lModule.addSerializer(«datatype.fqn()».class, new «datatype.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«datatype.name»Serializer«getJacksonVersionSuffix(jacksonVersion)»());
								lModule.addDeserializer(«datatype.fqn()».class, new «datatype.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«datatype.name»Deserializer«getJacksonVersionSuffix(jacksonVersion)»());
							«ENDIF»
						«ENDIF»
					«ENDFOREACH»
	
					// Return created module.
					return lModule;
				}
				
				«IF this.requiresCompositeDataTypeConverter()»
				/**
				 * Method creates a module that consists of all serializers / deserializers for composite data types.
				 */
				public static «getJacksonModuleFQN(jacksonVersion)» createCompositeDataTypeSerializerModule(com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter pCompositeTypeConverter) {
					// Create module for serializers / deserializers that are located in this package
					«getSimpleModuleFQN(jacksonVersion)» lModule = new «getSimpleModuleFQN(jacksonVersion)»("CompositeDataTypeSerializerModule." + «this.getNearestPackage().fqn()»«jacksonVersion.getJacksonSubpackage()».«name»«getJacksonVersionSuffix(jacksonVersion)».class.getName());
					
					// Add serializers and deserializers for composite data types				
					«FOREACH this.getOpenAPIDataTypes() AS datatype»
						«IF datatype.isStereotypeApplied("Ignore") == false»
							«IF datatype.generateInternalViewOfCompositeDataType() && isTargetRuntimeJEAF()== false && datatype.hasCompositeDateTypeCustomSerialization() == false»
								lModule.addSerializer(«datatype.fqn()».class, new «datatype.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«datatype.name»Serializer«getJacksonVersionSuffix(jacksonVersion)»(pCompositeTypeConverter));
								lModule.addDeserializer(«datatype.fqn()».class, new «datatype.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«datatype.name»Deserializer«getJacksonVersionSuffix(jacksonVersion)»(pCompositeTypeConverter));
							«ENDIF»
						«ENDIF»
					«ENDFOREACH»
	
					// Return created module.
					return lModule;
				}
				«ENDIF»
				
				/**
				 * Method creates a module that consists of all serializers / deserializers for enums.
				 */
				public static «getJacksonModuleFQN(jacksonVersion)» createEnumSerializerModule( ) {
					// Create module for serializers / deserializers that are located in this package
					«getSimpleModuleFQN(jacksonVersion)» lModule = new «getSimpleModuleFQN(jacksonVersion)»("EnumSerializerModule." + «this.getNearestPackage().fqn()»«jacksonVersion.getJacksonSubpackage()».«name»«getJacksonVersionSuffix(jacksonVersion)».class.getName());
					
					// Add serializers and deserializers for enumerations				
					«FOREACH this.clientDependency.supplier.typeSelect(uml::Package).allOwnedElements().typeSelect(JEAFEnumeration).select(e|e.extensibleEnum && e.ignore() == false).sortBy(e|e.name) AS enum»
					lModule.addSerializer(«enum.fqn()».class, new «enum.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«enum.name»Serializer«getJacksonVersionSuffix(jacksonVersion)»());
					lModule.addDeserializer(«enum.fqn()».class, new «enum.packageName()».serializers«jacksonVersion.getJacksonSubpackage()».«enum.name»Deserializer«getJacksonVersionSuffix(jacksonVersion)»());
					«ENDFOREACH»
					
					// Return created module.
					return lModule;
				}
			}
		«ENDFILE»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE GenerateObjectMapperFactory FOR ObjectMapperFactory -»
	«FOREACH getJacksonVersions() AS jacksonVersion»
		«FILE packagePath() + jacksonVersion.getJacksonSubpackagePath() + "/" + name + getJacksonVersionSuffix(jacksonVersion) + ".java" src_gen»
			«getFileHeader()»
			package «this.packageName()»«jacksonVersion.getJacksonSubpackage()»;
			
			import «getJsonAutoDetectFQN()»;
			import «getJsonIncludeFQN()».Include;		
			import «getObjectMapperFQN(jacksonVersion)»;
			import «getJsonMapperFQN(jacksonVersion)»;
			import «getJsonMapperFQN(jacksonVersion)».Builder;
	
			«EXPAND java::Helper::GenerateAnnotations-»
			/**
			 * Object Mapper Factory can be used to create a Jackson {@link ObjectMapper} that can be used to serialize and deserialize objects to / from JSON using Jackson. 
			 */
			public class «name»«getJacksonVersionSuffix(jacksonVersion)» {
				/**
				 * Method creates a ready-to-use Jackson Object Mapper. The created object will be configured so that it matches best to the generated classes. It will also use the serializer modules as it was defined in the UML model.			 
				 * «IF this.isCompositeDataTypeConverterRequiredForObjectMapperFactory()» @param pCompositeTypeConverter {@link com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter} implementation that should be used to serialize / deserialize composite data types.«ENDIF»
				 * @return {@link ObjectMapper} Created object mapper. The method never returns null.
				 */
				public static ObjectMapper createObjectMapper(
				    «IF this.isCompositeDataTypeConverterRequiredForObjectMapperFactory()»
				    com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter pCompositeTypeConverter
				    «ENDIF») {
				    
				    // Create builder for object mapper.
				    Builder lBuilder = JsonMapper.builder();
			
				    // Set default visibilities so that they match to the generated classes that are intended to be serialized using Jackson
				    «IF jacksonVersion.isJacksonVersion2()»
				    com.fasterxml.jackson.databind.introspect.VisibilityChecker<?> lVisibilityChecker = VisibilityChecker.Std.defaultInstance();
				    lVisibilityChecker = lVisibilityChecker.withFieldVisibility(JsonAutoDetect.Visibility.ANY);
				    lVisibilityChecker = lVisibilityChecker.withGetterVisibility(JsonAutoDetect.Visibility.NONE);
				    lVisibilityChecker = lVisibilityChecker.withIsGetterVisibility(JsonAutoDetect.Visibility.NONE);
				    lVisibilityChecker = lVisibilityChecker.withSetterVisibility(JsonAutoDetect.Visibility.NONE);
				    lVisibilityChecker = lVisibilityChecker.withCreatorVisibility(JsonAutoDetect.Visibility.ANY);
				    lBuilder.visibility(lVisibilityChecker);
					«ELSE»
					lBuilder.changeDefaultVisibility(v -> v.withFieldVisibility(JsonAutoDetect.Visibility.ANY));
					lBuilder.changeDefaultVisibility(v -> v.withGetterVisibility(JsonAutoDetect.Visibility.NONE));
					lBuilder.changeDefaultVisibility(v -> v.withIsGetterVisibility(JsonAutoDetect.Visibility.NONE));
					lBuilder.changeDefaultVisibility(v -> v.withSetterVisibility(JsonAutoDetect.Visibility.NONE));
					lBuilder.changeDefaultVisibility(v -> v.withCreatorVisibility(JsonAutoDetect.Visibility.NONE));

					// Configure which properties should be included by default.
					lBuilder.changeDefaultPropertyInclusion(i -> i.withValueInclusion(Include.«defaultPropertyInclusion.name»));
					lBuilder.changeDefaultPropertyInclusion(i -> i.withContentInclusion(Include.«defaultPropertyInclusion.name»));
					
					// For better backward compatibility with Jackson 2 we preserve the following settings as there were in Jackson 2
					//
					// For further details please have a look here: https://github.com/FasterXML/jackson/blob/main/jackson3/MIGRATING_TO_JACKSON_3.md
					lBuilder.disable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
					lBuilder.enable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS);
					«ENDIF»

				    // Configure mapper features
				    «FOREACH enabledMapperFeatures AS feature»
				    lBuilder.enable(«getMapperFeatureFQN(jacksonVersion)».«feature.toString()»);
				    «ENDFOREACH»
				    «FOREACH disabledMapperFeatures AS feature»
				    lBuilder.disable(«getMapperFeatureFQN(jacksonVersion)».«feature.toString()»);
				    «ENDFOREACH»
				    «FOREACH enabledSerializationFeatures AS feature»
				    lBuilder.enable(«getSerializationFeatureFQN(jacksonVersion)».«feature.toString()»);
				    «ENDFOREACH»
				    «FOREACH disabledSerializationFeatures AS feature»
				    lBuilder.disable(«getSerializationFeatureFQN(jacksonVersion)».«feature.toString()»);
				    «ENDFOREACH»
				    «FOREACH enabledDeserializationFeatures AS feature»
				    lBuilder.enable(«getDeserializationFeatureFQN(jacksonVersion)».«feature.toString()»);
				    «ENDFOREACH»
				    «FOREACH disabledDeserializationFeatures AS feature»
				    lBuilder.disable(«getDeserializationFeatureFQN(jacksonVersion)».«feature.toString()»);
				    «ENDFOREACH»
				    
				    «IF enabledMapperFeatures.size == 0»
				    lBuilder.enable(«getMapperFeatureFQN(jacksonVersion)».PROPAGATE_TRANSIENT_MARKER);
				    «ENDIF»
				    «IF disabledDeserializationFeatures.size == 0 && enableSemVerForJSON()»
				    lBuilder.disable(«getDeserializationFeatureFQN(jacksonVersion)».FAIL_ON_IGNORED_PROPERTIES);
				    «ENDIF»
			
				    // Create configured modules and add them as well.
				    «FOREACH this.clientDependency.supplier.typeSelect(ModuleFactory).sortBy(e|e.name) AS moduleFactory»
				    	lBuilder.addModule(«moduleFactory.getNearestPackage().fqn()»«jacksonVersion.getJacksonSubpackage()».«moduleFactory.name»«getJacksonVersionSuffix(jacksonVersion)».createDataTypeSerializerModule());
					    «IF moduleFactory.requiresCompositeDataTypeConverter()»
				    	lBuilder.addModule(«moduleFactory.getNearestPackage().fqn()»«jacksonVersion.getJacksonSubpackage()».«moduleFactory.name»«getJacksonVersionSuffix(jacksonVersion)».createCompositeDataTypeSerializerModule(pCompositeTypeConverter));
					    «ENDIF»
				    	lBuilder.addModule(«moduleFactory.getNearestPackage().fqn()»«jacksonVersion.getJacksonSubpackage()».«moduleFactory.name»«getJacksonVersionSuffix(jacksonVersion)».createEnumSerializerModule());
				    «ENDFOREACH»
			
				    // Create object mapper and return it
				    «IF jacksonVersion.isJacksonVersion2()»
					    JsonMapper lObjectMapper = lBuilder.build();
					    lObjectMapper.setDefaultPropertyInclusion(Include.«defaultPropertyInclusion.name»);
					    return lObjectMapper;
				    «ELSE»
					    return lBuilder.build();
				    «ENDIF»
				}
			}
		«ENDFILE»
	«ENDFOREACH»
«ENDDEFINE»

