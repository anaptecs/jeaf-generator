«EXTENSION java::Naming»
«EXTENSION java::GeneratorCommons»
«EXTENSION java::OpenAPIFunctions»
«EXTENSION entity::ModelProperties»
«EXTENSION jeaf::RESTFunctions»
«EXTENSION java::OpenAPIFunctions»

«EXTENSION functions::RESTResource»
«EXTENSION functions::RESTOperation»
«EXTENSION functions::JEAFService»
«EXTENSION functions::Reactive»
«EXTENSION functions::Operation»
«EXTENSION functions::Builder»
«EXTENSION functions::Class»


«IMPORT uml»
«IMPORT JMM»

«DEFINE RESTResourceClass(boolean reactive) FOR RESTResource»
«FILE packagePath()+"/resource/" + this.getResourceName(reactive) + ".java" src_gen»
«getFileHeader()»
package «packageName()».resource;

«EXPAND functions::Javadoc::JavadocForType»
«IF isRESTLibrarySpringWebMVC()»
	«IF this.getRESTPath().length > 0»
	@org.springframework.web.bind.annotation.RequestMapping(path = "«this.getRESTPath()»")
	«ENDIF» 
	@org.springframework.web.bind.annotation.RestController
«ELSE»
	@«getEnterpriseJavaPackage()».ws.rs.Path("«IF this.getRESTPath().length > 0»«this.getRESTPath()»«ELSE»/«ENDIF»")
	«IF consumes.size > 0»@«getEnterpriseJavaPackage()».ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»«getEnterpriseJavaPackage()».ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@«getEnterpriseJavaPackage()».ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»«getEnterpriseJavaPackage()».ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
«ENDIF»
«EXPAND java::Helper::GenerateAnnotations -»
public class «this.getResourceName(reactive)» {
	
	«IF this.hasCompositeDataTypes() && generatePublicObjectView() == false»
		«IF isTargetRuntimeSpring()»
			«IF isRESTLibrarySpringWebMVC()»
				/**
				 * REST interface makes usage of so called composite data types. As Spring itself is not able to do conversions from a String representation into a real object this is done in the generated REST Controller.
				 */
				private final com.fasterxml.jackson.databind.ObjectMapper objectMapper;
			«ENDIF»
			«IF isRESTLibraryJAXRS()»
				/**
				 * REST interface makes usage of so called composite data types. As Spring itself is not able to do conversions from a String representation into a real object this is done in the generated REST Controller.
				 */
				@org.springframework.beans.factory.annotation.Autowired
				private com.fasterxml.jackson.databind.ObjectMapper objectMapper;
			«ENDIF»
		«ENDIF»		
	«ENDIF»
	
    «IF isTargetRuntimeSpring()»
        «IF isRESTLibrarySpringWebMVC()»
            «IF generateRESTRequestValidation() || generateRESTResponseValidation()»
	            /**
	             * REST Controller was generated with request / response validation enabled. The actual validation will be delegated to the implementation of this interface.
	             */
	            private final com.anaptecs.jeaf.validation.api.ValidationExecutor validationExecutor;
            «ENDIF»
        «ENDIF»
        «IF isRESTLibraryJAXRS()»
            «IF generateRESTRequestValidation() || generateRESTResponseValidation()»
	            /**
	             * REST Controller was generated with request / response validation enabled. The actual validation will be delegated
	             * to the implementation of this interface.
	             */
	            @org.springframework.beans.factory.annotation.Autowired
	            private com.anaptecs.jeaf.validation.api.ValidationExecutor validationExecutor;
            «ENDIF»
        «ENDIF»
    «ENDIF»
    
	«IF this.requiresCustomHeadersFilter()»
	  «IF isTargetRuntimeSpring()»
		  «IF isRESTLibrarySpringWebMVC()»
			  /**
			   * Filter is used to provide only those headers that are configured to be processed by this REST resource.
			   */
			  private final com.anaptecs.jeaf.rest.resource.api.CustomHeaderFilter customHeaderFilter;
		  «ENDIF»
            «IF isRESTLibraryJAXRS()»
              /**
               * Filter is used to provide only those headers that are configured to be processed by this REST resource.
               */
              @org.springframework.beans.factory.annotation.Autowired
              private com.anaptecs.jeaf.rest.resource.api.CustomHeaderFilter customHeaderFilter;
            «ENDIF»
	  «ENDIF»
	«ENDIF»

	«IF isTargetRuntimeSpring()»
		«IF isRESTLibrarySpringWebMVC()»
			/**
			 * All request to this class will be delegated to {@link «this.fqn()»}.
			 */
			private final «this.asJEAFService().getServiceNameFQN(reactive)» «name.toFirstLower()»;
		
			/**
			 * Initialize object.
			 * 
			 * @param p«name» Dependency on concrete {@link «this.fqn()»} implementation that should be used.
			 «IF this.hasCompositeDataTypes() -»
			 * @param pCompositeTypeConverter Composite type converter is used convert types from their string representation to a real object that can be processed internally.
			 «ENDIF -»
			 */
			public «this.getResourceName(reactive)»( «this.asJEAFService().getServiceNameFQN(reactive)» p«name» «IF this.hasCompositeDataTypes()», com.fasterxml.jackson.databind.ObjectMapper pObjectMapper«ENDIF»«IF generateRESTRequestValidation() || generateRESTResponseValidation()», com.anaptecs.jeaf.validation.api.ValidationExecutor pValidationExecutor«ENDIF»«IF this.requiresCustomHeadersFilter()», com.anaptecs.jeaf.rest.resource.api.CustomHeaderFilter pCustomHeaderFilter«ENDIF») {
			  «name.toFirstLower()» = p«name»;
			  «IF this.hasCompositeDataTypes()»
			  objectMapper = pObjectMapper;
			  «ENDIF»
			  «IF generateRESTRequestValidation() || generateRESTResponseValidation()»
			  validationExecutor = pValidationExecutor;
			  «ENDIF»
			  «IF this.requiresCustomHeadersFilter()»
              customHeaderFilter = pCustomHeaderFilter;
			  «ENDIF»
			}
		«ENDIF»
		«IF isRESTLibraryJAXRS()»
			/**
			 * All request to this class will be delegated to {@link «this.fqn()»}.
			 */
			@org.springframework.beans.factory.annotation.Autowired
			private «this.asJEAFService().getServiceNameFQN(reactive)» «name.toFirstLower()»;
		«ENDIF»
	«ENDIF»
	
	«EXPAND RESTOperationImpl(this, reactive) FOREACH this.getAllOperations().typeSelect(RESTOperation)»
	
	«IF this.hasCompositeDataTypes() && generatePublicObjectView() == false»
		«IF isTargetRuntimeSpring()»
			/**
			 * Method is used to deserialize composite data types that are passed as some kind of parameter (not body) to this class. They need to be deserialized in the generated code as this is not supported by the used REST framework.
			 * 
			 * @param pCompositeDataTypeAsString String representation of the composite data type. The parameter may be null.
			 * @param pType Type of which the returned objects is supposed to be. The parameter must not be null.
			 * @return T Instance of the expected type or null if <code>pCompositeDataTypeAsString</code> is null.
			 */
			private <T> T deserializeCompositeDataType( String pCompositeDataTypeAsString, java.lang.Class<T> pType ) {
			  try {
			    T lObject;
			    if (pCompositeDataTypeAsString != null) {
			      java.lang.StringBuilder lBuilder = new StringBuilder(pCompositeDataTypeAsString.length() + 4);
			      lBuilder.append("\"");
			      lBuilder.append(pCompositeDataTypeAsString);
			      lBuilder.append("\"");
			      lObject = objectMapper.readValue(lBuilder.toString(), pType);
			    }
			    else {
			      lObject = null;
			    }
			    return lObject;
			  }
			  catch (com.fasterxml.jackson.core.JsonProcessingException e) {
			    throw new IllegalArgumentException("Unable to deserialize composite data type " + pType.getName() + " from String '" + pCompositeDataTypeAsString + "'. Details: " + e.getMessage(), e);
			  }
			}
		«ENDIF»
        «REM»
        «IF isTargetRuntimeJEAF()»
            /**
             * Method is used to deserialize composite data types that are passed as some kind of parameter (not body) to this class. They need to be deserialized in the generated code as this is not supported by the used REST framework.
             * 
             * @param pCompositeDataTypeAsString String representation of the composite data type. The parameter may be null.
             * @param pType Type of which the returned objects is supposed to be. The parameter must not be null.
             * @return T Instance of the expected type or null if <code>pCompositeDataTypeAsString</code> is null.
             */
            private <T> T deserializeCompositeDataType( String pCompositeDataTypeAsString, java.lang.Class<T> pType ) {
                T lObject;
                if (pCompositeDataTypeAsString != null) {
                  java.lang.StringBuilder lBuilder = new StringBuilder(pCompositeDataTypeAsString.length() + 4);
                  lBuilder.append("\"");
                  lBuilder.append(pCompositeDataTypeAsString);
                  lBuilder.append("\"");
                  lObject = com.anaptecs.jeaf.json.api.JSONTools.getJSONTools().read(lBuilder.toString(), pType);
                }
                else {
                  lObject = null;
                }
                return lObject;
            }
        «ENDIF»
        «ENDREM»
	«ENDIF»
	
	«IF isTargetRuntimeJEAF()»
		/**
		 * Method returns reference to service to which all REST requests will be delegated.
		 *
		 * @return «this.name» Service instance to which all requests will be delegated.
		 */
		private «this.fqn()» get«name»() {
		  return com.anaptecs.jeaf.core.api.JEAF.getService(«this.asJEAFService().getServiceNameFQN(reactive)».class);
		}
	«ENDIF»
}
«ENDFILE»
«ENDDEFINE»


«DEFINE RESTOperationImpl(JMM::RESTResource restResource, boolean reactive) FOR RESTOperation»
	«IF isRESTLibrarySpringWebMVC()»
		«EXPAND SpringRESTControllerOperationImpl(restResource, reactive)»
	«ELSE»
		«IF async == false»
			«EXPAND SyncJAXRSOperationImpl(restResource) FOR this»
		«ELSE»
			«EXPAND AsyncJAXRSOperationImpl(restResource) FOR this»
		«ENDIF»
	«ENDIF»	
«ENDDEFINE»

«DEFINE SyncJAXRSOperationImpl(JMM::RESTResource restResource) FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	«IF this.getRESTOperationPath(restResource).length > 0»@«getEnterpriseJavaPackage()».ws.rs.Path("«this.getRESTOperationPath(restResource)»")«ENDIF»
	«EXPAND HTTPMethods»
	«IF consumes.size > 0»@«getEnterpriseJavaPackage()».ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»«getEnterpriseJavaPackage()».ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@«getEnterpriseJavaPackage()».ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»«getEnterpriseJavaPackage()».ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
	«EXPAND java::Helper::GenerateAnnotations-»
	«EXPAND java::Helper::GenerateAnnotations FOR this.getReturnResult()-»
	«EXPAND java::Helper::NotNullAnnotationForParameter("RESTResource") FOR this.getReturnResult()-»
	public «getEnterpriseJavaPackage()».ws.rs.core.Response  «name» («EXPAND RESTParameterSignature FOR this» «IF this.ownedParameter.select(e|e.hasParamCustomHeaders()).size > 0» «IF ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false).size > 0»,«ENDIF» @«getEnterpriseJavaPackage()».ws.rs.core.Context «getEnterpriseJavaPackage()».ws.rs.core.HttpHeaders pHeaders«ENDIF»)«getThrownExceptionsAsString()»{
	  «IF this.hasDataTypeParameters()»
	  // Convert basic type parameters into "real" objects.
	  	«FOREACH this.getDataTypeParameters() AS basicParam»
	    	«IF basicParam.type.isCompositeDataTypeForRESTResource()»
	    		«IF generatePublicObjectView()»
					«IF basicParam.isMultivalued() == false»
						«IF basicParam.type.isPrimitiveType() == false»
						«basicParam.type.fqn()» «basicParam.name»;
						if («basicParam.name»AsBasicType != null) {
						  «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
						}
						else {
						  «basicParam.name» = null;
						}
						«ELSE»
						  «basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
						«ENDIF»
					«ELSE»
		    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
					    if («basicParam.name»AsBasicType != null) {
					      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
					      for (String lNext : «basicParam.name»AsBasicType) {
				    		«basicParam.name».add(«basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(lNext).build());
					      }
					    }
					    else {
					      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
					    }
					«ENDIF»
	    		«ELSE»
	    			«IF basicParam.isMultivalued() == false»
                        «basicParam.type.fqn()» «basicParam.name» = this.deserializeCompositeDataType(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class);
			    	«ELSE»
		    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
					    if («basicParam.name»AsBasicType != null) {
					      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
					      for (String lNext : «basicParam.name»AsBasicType) {
			    			«basicParam.name».add(this.deserializeCompositeDataType(lNext, «basicParam.type.fqn()».class));
					      }
					    }
					    else {
					      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
					    }
			    	«ENDIF»
	    		«ENDIF»
	    	«ELSE»
	    		«IF basicParam.isMultivalued() == false»
	    			«IF basicParam.type.isPrimitiveType() == false»
		    			«basicParam.type.fqn()» «basicParam.name»;
		    			if («basicParam.name»AsBasicType != null) {
		    			  «basicParam.name» = «basicParam.type.fqn()».builder().«basicParam.type.attribute().select(e|e.isStatic == false).first().asSetter()»(«basicParam.name»AsBasicType).build();
		    			}
	                    else {
	                      «basicParam.name» = null;
	                    }
                    «ELSE»
                        «basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().«basicParam.type.attribute().select(e|e.isStatic == false).first().asSetter()»(«basicParam.name»AsBasicType).build(); 
                    «ENDIF»
	    		«ELSE»
	    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
				    if («basicParam.name»AsBasicType != null) {
				      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
				      for («basicParam.type.attribute().select(e|e.isStatic == false).first().fqn()» lNext : «basicParam.name»AsBasicType) {
				        «basicParam.name».add(«basicParam.type.fqn()».builder().«basicParam.type.attribute().select(e|e.isStatic == false).first().asSetter()»(lNext).build());
				      }
				    }
				    else {
				      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
				    }
	    		«ENDIF»
	    	«ENDIF»
	  	«ENDFOREACH»
	  «ENDIF»
	  
	  «FOREACH this.ownedParameter.select(e|e.isInputParameter() && e.isParameterSuppressed() == false && e.hasParamCustomHeaders()) AS beanParam»
	    // Add custom headers.
	    for (java.util.Map.Entry<String, java.util.List<String>> lNextEntry : pHeaders.getRequestHeaders().entrySet()) {
	         «IF isTargetRuntimeSpring() && filterCustomHeaders()»
	         if (customHeaderFilter.test(lNextEntry.getKey())) {
	         «ENDIF»	      
	           «beanParam.name».addCustomHeader(lNextEntry.getKey(), lNextEntry.getValue().get(0));
             «IF isTargetRuntimeSpring() && filterCustomHeaders()»
             }
             «ENDIF»          
	    }
	  «ENDFOREACH»

      «IF generateRESTRequestValidation() && this.getInputParameters().select(e|e.isParameterSuppressed() == false).isEmpty == false»
        «IF isTargetRuntimeSpring()»
	        // Validate request parameter(s).
	        validationExecutor.validateRequest(«((NamedElement)owner).fqn()».class, «this.asParameterListNames()»);
        «ENDIF»
      «ENDIF»
      
      // Delegate request to service.
      «IF isTargetRuntimeJEAF()»
		  «restResource.fqn()» lService = this.get«restResource.name»();
		  «IF getReturnTypeName() != "void"»
		  «getReturnTypeName()» lResult = lService.«this.name»(«this.asParameterListNames()»);
		  return «getEnterpriseJavaPackage()».ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
		  «ELSE»
		  lService.«this.name»(«this.asParameterListNames()»);
		  return «getEnterpriseJavaPackage()».ws.rs.core.Response.status(«EXPAND StatusCode»).build();
		  «ENDIF»
	  «ENDIF»
      «IF isTargetRuntimeSpring()»
		  «IF getReturnTypeName() != "void"»
		  «getReturnTypeName()» lResult = «restResource.name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
		  
		  «IF generateRESTResponseValidation()»
	         // Validate response and return it.
	         validationExecutor.validateResponse(«restResource.fqn()».class, lResult);
	      «ENDIF»
		  return «getEnterpriseJavaPackage()».ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
		  «ELSE»
		  «restResource.name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
		  return «getEnterpriseJavaPackage()».ws.rs.core.Response.status(«EXPAND StatusCode»).build();
		  «ENDIF»
	  «ENDIF»
	}
«ENDDEFINE»

«DEFINE SpringRESTControllerOperationImpl(JMM::RESTResource restResource, boolean reactive) FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	«IF isTargetRuntimeSpring() && generateSecurityAnnotation() && hasSecurityRoles()»
		«IF useDeprecatedSpringSecuredAnnotation() == false»
			@org.springframework.security.access.prepost.PreAuthorize("hasAnyRole(«FOREACH getSecurityRoles() AS role SEPARATOR ", " »'«role»'«ENDFOREACH»)")
		«ELSE»
			@org.springframework.security.access.annotation.Secured({«FOREACH getSecurityRoles() AS role SEPARATOR ", " »"«role»"«ENDFOREACH»})
		«ENDIF»
	«ENDIF»
	@org.springframework.web.bind.annotation.ResponseStatus(org.springframework.http.HttpStatus.«getJAXRSStatusCodeName(this.getStatusCodeName())»)
	@org.springframework.web.bind.annotation.RequestMapping(
	«IF this.getRESTOperationPath(restResource).length > 0»path = "«this.getRESTOperationPath(restResource)»",«ENDIF»
	«IF consumes.size > 0»consumes = {«FOREACH consumes AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»},«ENDIF»
	«IF produces.size > 0»produces = {«FOREACH produces AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»},«ENDIF»
	method = { «FOREACH httpMethods AS httpMethod SEPARATOR ","»org.springframework.web.bind.annotation.RequestMethod.«httpMethod»«ENDFOREACH»}
	)
	«EXPAND java::Helper::GenerateAnnotations-»
	«EXPAND java::Helper::GenerateAnnotations FOR this.getReturnResult()-»
	«EXPAND java::Helper::NotNullAnnotationForParameter("RESTResource") FOR this.getReturnResult()-»
	public «getReturnTypeName().getReactiveAwareTypeName(reactive)»  «name» («EXPAND SpringRESTParameterSignature(reactive) FOR this» «IF this.ownedParameter.select(e|e.hasParamCustomHeaders()).size > 0» «IF ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false).size > 0»,«ENDIF» @org.springframework.web.bind.annotation.RequestHeader java.util.Map<String, String> pHeaders«ENDIF»«IF reactive»«IF ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false).size > 0»,«ENDIF» «getServerWebExchangeTypeName()» pServerWebExchange«ENDIF»)«getThrownExceptionsAsString()»{
	  «IF this.hasBeanParameters()»
	  // Convert parameters into object as "BeanParams" are not supported by Spring Web. This way we do not pollute the service interface but "only" our REST controller.
	  «ENDIF»
	  «FOREACH this.getBeanParams() AS beanParam»
		  var «beanParam.name.toLocalVar()»Builder = «beanParam.getTypeName()».builder();
		  «FOREACH beanParam.type.getAllAttributesFromHierarchy().select(e|e.isPropertySuppressed() == false) AS attribute»
		  		«IF attribute.type.isOpenAPIDataType()»
  					// Handle bean parameter «beanParam.name».«attribute.name»
		  			«IF attribute.type.isCompositeDataTypeForRESTResource()»
		  				if(«attribute.asParameter()»AsBasicType != null) {
		  				«IF generatePublicObjectView()»
		  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».builder().set«attribute.type.attribute().select(e|e.isStatic == false).first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType).build());
		  				«ELSE»
		  					«IF attribute.isMultivalued() == false»
		  						«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(this.deserializeCompositeDataType(«attribute.asParameter()»AsBasicType, «attribute.type.fqn()».class));
		  					«ELSE»
		  						// Handle bean parameter «beanParam.name».«attribute.name»
		  						«IF attribute.isCollectionType()»
			  						«attribute.getCollectionType()»<«attribute.type.fqn()»> «attribute.asLocalVar()» = new «attribute.getCollectionImplType()»<«attribute.type.fqn()»>();
			  						for(String lNext : «attribute.asParameter()»AsBasicType) {
			  							«attribute.asLocalVar()».add(this.deserializeCompositeDataType(lNext, «attribute.type.fqn()».class));
			  						}
			  					«ELSE»
			  						«attribute.type.fqn()»[] «attribute.asLocalVar()»  = new «attribute.type.fqn()»[«attribute.asParameter()»AsBasicType.length];
			  						for(int i = 0; i < «attribute.asParameter()»AsBasicType.length; i++) {
			  							«attribute.asLocalVar()»[i] = this.deserializeCompositeDataType(«attribute.asParameter()»AsBasicType[i], «attribute.type.fqn()».class);
			  						}
			  					«ENDIF»
			  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asLocalVar()»);
		  					«ENDIF»
		  				«ENDIF»
		  				}
		  			«ELSE»
		  				«IF attribute.isMultivalued() == false»
		  					«IF attribute.type.attribute().select(e|e.isStatic == false).first().type.isPrimitiveType() == false»
			  					if(«attribute.asParameter()»AsBasicType != null) {
			  					  «beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».builder().set«attribute.type.attribute().select(e|e.isStatic == false).first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType).build());
			  					}
		  					«ELSE»
		  					   «beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».builder().set«attribute.type.attribute().select(e|e.isStatic == false).first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType).build());
		  					«ENDIF»
		  				«ELSE»
		  					if(«attribute.asParameter()»AsBasicType != null) {
		  					«IF attribute.isCollectionType()»
		  						«attribute.getCollectionType()»<«attribute.type.fqn()»> «attribute.asLocalVar()»  = new «attribute.getCollectionImplType()»<«attribute.type.fqn()»>();
		  						for(«attribute.type.attribute().select(e|e.isStatic == false).first().fqn()» lNext :  «attribute.asParameter()»AsBasicType) {
		  							«attribute.asLocalVar()».add(«attribute.type.fqn()».builder().set«attribute.type.attribute().select(e|e.isStatic == false).first().name.toFirstUpper()»(lNext).build());
		  						}
		  					«ELSE»
		  						«attribute.type.fqn()»[] «attribute.asLocalVar()»  = new «attribute.type.fqn()»[«attribute.asParameter()»AsBasicType.length];
		  						for(int i = 0; i < «attribute.asParameter()»AsBasicType.length; i++) {
		  							«attribute.asLocalVar()»[i] = «attribute.type.fqn()».builder().set«attribute.type.attribute().select(e|e.isStatic == false).first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType[i]).build();
		  						}
		  					«ENDIF»
		  						«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asLocalVar()»);
		  					}
		  				«ENDIF»
		  			«ENDIF»
		  		«ELSE»
		  			«IF attribute.type.isAnyDateType()»
		  				// Handle bean parameter «beanParam.name».«attribute.name»
			  			«IF attribute.isMultivalued() == false»
				  			if(«attribute.asParameter()»AsBasicType != null) {
				  				«IF attribute.type.belongsToJavaTimeAPI()»
				  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».parse(«attribute.asParameter()»AsBasicType));
				  				«ELSE»
									«IF attribute.type.isSQLTimestamp() || attribute.type.isSQLDate() || attribute.type.isSQLTime()»
						  				«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».valueOf(«attribute.asParameter()»AsBasicType));
						  			«ELSE»				  						
				  						try {
				  							«IF attribute.type.isUtilDate()»
				  								java.util.Date lDate = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(«attribute.asParameter()»AsBasicType);
				  								«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(lDate);
						  					«ELSE»«IF attribute.type.isCalendar()»
										        java.util.Date lDate = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(«attribute.asParameter()»AsBasicType);
										        java.util.Calendar lCalendar = java.util.Calendar.getInstance();
										        lCalendar.setTime(lDate);
						  						«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(lCalendar);
						  					«ELSE»«ENDIF»«ENDIF»
										}
										catch (java.text.ParseException e) {
										  throw new IllegalArgumentException(e.getMessage());
										}
									«ENDIF»
				  				«ENDIF»
				  			}
			  			«ELSE»
							if(«attribute.asParameter()»AsBasicType != null) {
								«IF attribute.type.isCalendar() || attribute.type.isUtilDate()»
								try {
								«ENDIF»
								«IF attribute.isCollectionType()»
						  			«attribute.getCollectionType()»<«attribute.type.fqn()»> «attribute.asLocalVar()» = new «attribute.getCollectionImplType()»<«attribute.type.fqn()»>();
									for (int i = 0; i < «attribute.asParameter()»AsBasicType.length; i++) {
									  «IF attribute.type.belongsToJavaTimeAPI()» 
									  	«attribute.asLocalVar()».add(«attribute.type.fqn()».parse(«attribute.asParameter()»AsBasicType[i]));
									  «ELSE»
									  	«IF attribute.type.isCalendar()»
										  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
										  	java.util.Date lDate = lDateFormat.parse(«attribute.asParameter()»AsBasicType[i]);
									        java.util.Calendar lCalendar = java.util.Calendar.getInstance();
									        lCalendar.setTime(lDate);
					  						«attribute.asLocalVar()».add(lCalendar);
									  	«ELSE»«IF attribute.type.isUtilDate()»
										  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
										  	java.util.Date lDate = lDateFormat.parse(«attribute.asParameter()»AsBasicType[i]);
									  		«attribute.asLocalVar()».add(lDate);
									  	«ELSE»«IF attribute.type.isSQLTimestamp() || attribute.type.isSQLDate() || attribute.type.isSQLTime()»
									  		«attribute.asLocalVar()».add(«attribute.type.fqn()».valueOf(«attribute.asParameter()»AsBasicType[i]));
									  	«ENDIF»«ENDIF»«ENDIF»
									  «ENDIF»
									}
								«ELSE»
									«attribute.type.fqn()»[] «attribute.asLocalVar()» = new «attribute.type.fqn()»[«attribute.asParameter()»AsBasicType.length];
									for (int i = 0; i < «attribute.asParameter()»AsBasicType.length; i++) {
									  «IF attribute.type.belongsToJavaTimeAPI()» 
									  	«attribute.asLocalVar()»[i] = «attribute.type.fqn()».parse(«attribute.asParameter()»AsBasicType[i]);
									  «ELSE»
									  	«IF attribute.type.isCalendar()»
										  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
										  	java.util.Date lDate = lDateFormat.parse(«attribute.asParameter()»AsBasicType[i]);
									        java.util.Calendar lCalendar = java.util.Calendar.getInstance();
									        lCalendar.setTime(lDate);
					  						«attribute.asLocalVar()»[i] = lCalendar;
									  	«ELSE»«IF attribute.type.isUtilDate()»
										  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
										  	java.util.Date lDate = lDateFormat.parse(«attribute.asParameter()»AsBasicType[i]);
									  		«attribute.asLocalVar()»[i] = lDate;
									  	«ELSE»«IF attribute.type.isSQLTimestamp() || attribute.type.isSQLDate() || attribute.type.isSQLTime()»
									  		«attribute.asLocalVar()»[i] = «attribute.type.fqn()».valueOf(«attribute.asParameter()»AsBasicType[i]);
									  	«ENDIF»«ENDIF»«ENDIF»
									  «ENDIF»
									}
								«ENDIF»
								«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asLocalVar()»);
								«IF attribute.type.isCalendar() || attribute.type.isUtilDate()»
								}
								catch (java.text.ParseException e) {
								  throw new IllegalArgumentException(e.getMessage());
								}
								«ENDIF»
							}			  			
			  			«ENDIF»
		  			«ELSE»
		  				«IF attribute.type.isPrimitiveType() && attribute.type.isByteType() && attribute.isMultivalued()»
		  				    // Decode base64 encoded String back to byte[]
		  				    if(«attribute.asParameter()» != null) {
		  				       «beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(java.util.Base64.getDecoder().decode(«attribute.asParameter()»));
		  				    }
		  				«ELSE»
		  				    «beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asParameter()»);
		  				«ENDIF»
		  			«ENDIF»
		  		«ENDIF»
		  «ENDFOREACH»
		  «IF beanParam.hasParamCustomHeaders()»
			// Add custom headers.
			for (java.util.Map.Entry<String, String> lNextEntry : pHeaders.entrySet()) {
			 «IF filterCustomHeaders()»
			 if (customHeaderFilter.test(lNextEntry.getKey())) {
			 «ENDIF»
			    «beanParam.name.toLocalVar()»Builder.addCustomHeader(lNextEntry.getKey(), lNextEntry.getValue());
             «IF filterCustomHeaders()»
             }
             «ENDIF»
			}		  
		  «ENDIF»
          «beanParam.getTypeName()» «beanParam.name» = «beanParam.name.toLocalVar()»Builder.build();
	  «ENDFOREACH»
	  «IF this.hasDataTypeParameters()»
	  // Convert basic type parameters into "real" objects.
	  	«FOREACH this.getDataTypeParameters() AS basicParam»
	    	«IF basicParam.type.isCompositeDataTypeForRESTResource()»
	    		«IF generatePublicObjectView()»
                    «IF basicParam.type.isPrimitiveType() == false»
	                    «basicParam.type.fqn()» «basicParam.name»;
	                    if («basicParam.name»AsBasicType != null) {
						  «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
						}
	                    else {
	                      «basicParam.name» = null;
	                    }
                    «ELSE»
                        «basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
                    «ENDIF»
	    		«ELSE»
	    			«IF basicParam.isMultivalued() == false»
    				     «basicParam.type.fqn()» «basicParam.name» = this.deserializeCompositeDataType(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class);
	    			«ELSE»
					    «basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
					    if («basicParam.name»AsBasicType != null) {
					      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
					      for (String lNext : «basicParam.name»AsBasicType) {
					        «basicParam.name».add(this.deserializeCompositeDataType(lNext, «basicParam.type.fqn()».class));
					      }
					    }
					    else {
					      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
					    }
	    			«ENDIF»
	    		«ENDIF»
	    	«ELSE»
	    		«IF basicParam.isMultivalued() == false»
                    «IF basicParam.type.isPrimitiveType() == false»
	                    «basicParam.type.fqn()» «basicParam.name»;
	                    if («basicParam.name»AsBasicType != null) {
		    			  «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.attribute().select(e|e.isStatic == false).first().name.toFirstUpper()»(«basicParam.name»AsBasicType).build();
	                    }
	                    else {
	                      «basicParam.name» = null;
	                    }
                    «ELSE»
                        «basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.attribute().select(e|e.isStatic == false).first().name.toFirstUpper()»(«basicParam.name»AsBasicType).build();
                    «ENDIF»
	    		«ELSE»
	    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
				    if («basicParam.name»AsBasicType != null) {
				      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
				      for («basicParam.type.attribute().select(e|e.isStatic == false).first().fqn()» lNext : «basicParam.name»AsBasicType) {
				        «basicParam.name».add(«basicParam.type.fqn()».builder().«basicParam.type.attribute().select(e|e.isStatic == false).first().asSetter()»(lNext).build());
				      }
				    }
				    else {
				      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
				    }
	    		«ENDIF»
	    	«ENDIF»
	  	«ENDFOREACH»
	  «ENDIF»
	  
	  «IF this.hasDateParameters()»
	  // Convert date types into real objects.
	  	«FOREACH this.getDateParameters() AS dateParam»
  			«IF dateParam.isMultivalued() == false»
	  			«dateParam.type.fqn()» «dateParam.name»;
	  			if(«dateParam.name»AsBasicType != null) {
  				«IF dateParam.type.belongsToJavaTimeAPI()»
  					«dateParam.name» = «dateParam.type.fqn()».parse(«dateParam.name»AsBasicType);
  				«ELSE»
					«IF dateParam.type.isSQLTimestamp() || dateParam.type.isSQLDate() || dateParam.type.isSQLTime()»
						«dateParam.name» = «dateParam.type.fqn()».valueOf(«dateParam.name»AsBasicType);
					«ELSE»
						try {
							«IF dateParam.type.isUtilDate()»
								«dateParam.name» = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(«dateParam.name»AsBasicType);
							«ELSE»«IF dateParam.type.isCalendar()»
								java.util.Date lDate = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(«dateParam.name»AsBasicType);
								«dateParam.name» = java.util.Calendar.getInstance();
								«dateParam.name».setTime(lDate);
							«ELSE»«ENDIF»«ENDIF»
						}
						catch (java.text.ParseException e) {
							throw new IllegalArgumentException(e.getMessage());
						}
					«ENDIF»
  				«ENDIF»
	  			}
	  			else {
	  				«dateParam.name» = null;
	  			}
  			«ELSE»
	  			«dateParam.getCollectionType()»<«dateParam.type.fqn()»> «dateParam.name»;
	  			if(«dateParam.name»AsBasicType != null) {
					«IF dateParam.type.isCalendar() || dateParam.type.isUtilDate()»
					try {
					«ENDIF»
	  				«dateParam.name» = new «dateParam.getCollectionImplType()»<«dateParam.type.fqn()»>();
					for (int i = 0; i < «dateParam.name»AsBasicType.length; i++) {
					  «IF dateParam.type.belongsToJavaTimeAPI()» 
					  	«dateParam.name».add(«dateParam.type.fqn()».parse(«dateParam.name»AsBasicType[i]));
					  «ELSE»
					  	«IF dateParam.type.isCalendar()»
						  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
						  	java.util.Date lDate = lDateFormat.parse(«dateParam.name»AsBasicType[i]);
					        java.util.Calendar lCalendar = java.util.Calendar.getInstance();
					        lCalendar.setTime(lDate);
	  						«dateParam.name».add(lCalendar);
					  	«ELSE»«IF dateParam.type.isUtilDate()»
						  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
						  	java.util.Date lDate = lDateFormat.parse(«dateParam.name»AsBasicType[i]);
					  		«dateParam.name».add(lDate);
					  	«ELSE»«IF dateParam.type.isSQLTimestamp() || dateParam.type.isSQLTime() || dateParam.type.isSQLTime()»
					  		«dateParam.name».add(«dateParam.type.fqn()».valueOf(«dateParam.name»AsBasicType[i]));
					  	«ENDIF»«ENDIF»«ENDIF»
					  «ENDIF»
					}
					«IF dateParam.type.isCalendar() || dateParam.type.isUtilDate()»
					}
					catch (java.text.ParseException e) {
					  throw new IllegalArgumentException(e.getMessage());
					}
					«ENDIF»
				}
  				else {
  					«dateParam.name» = «dateParam.getEmptyCollectionOperation()»;
  				}
  			«ENDIF»
	  	«ENDFOREACH»
	  «ENDIF»
	  
	  «IF this.hasByteArrayHeaderParameters()»
	       «FOREACH this.getByteArrayHeaderParameters() AS byteArrayParam»
	       byte[] «byteArrayParam.name»;
	       if(«byteArrayParam.name»AsString != null) {
	           «byteArrayParam.name» = java.util.Base64.getDecoder().decode(«byteArrayParam.name»AsString);
	       }
	       else {
	           «byteArrayParam.name» = null;
	       }	       
	       «ENDFOREACH»
	  «ENDIF»
	  
	  «IF reactive»
	      «IF this.hasRequestBody()»
	            return «this.getRequestBodyParameters().first().name» 
            «IF generateRESTRequestValidation() && this.getInputParameters().select(e|e.isParameterSuppressed() == false).isEmpty == false»
		            .flatMap(«this.getRequestBodyParameters().first().name»Body -> {
		                // Validate request parameter(s).
		                validationExecutor.validateRequest(«restResource.fqn()»Reactive.class, «this.asRESTParameterListNames(reactive)»);
            «ENDIF»
                        // Delegate request to service.
                        return «restResource.name.toFirstLower()».«this.name»(«this.asRESTParameterListNames(reactive)»);
                    })
            «IF getReturnTypeName() != "void"»
                «IF generateRESTResponseValidation()»
		            .doOnNext(lResponse ->
		                // Validate response.
		                validationExecutor.validateResponse(«restResource.fqn()»Reactive.class, lResponse)
		            );
		        «ELSE»
		            ;
		        «ENDIF»         
	        «ELSE»
	            ;
	        «ENDIF» 
	      «ELSE»
                return «getMonoTypeName()»
                    .defer(() -> {
            «IF generateRESTRequestValidation() && this.getInputParameters().select(e|e.isParameterSuppressed() == false).isEmpty == false»
                        // Validate request parameter(s).
                        validationExecutor.validateRequest(«restResource.fqn()»Reactive.class, «this.asRESTParameterListNames(reactive)»);
            «ENDIF»
                        // Delegate request to service.
                        return «restResource.name.toFirstLower()».«this.name»(«this.asRESTParameterListNames(reactive)»);
                    })           
            «IF getReturnTypeName() != "void"»
                «IF generateRESTResponseValidation()»
                    .doOnNext(lResponse ->
                        // Validate response.
                        validationExecutor.validateResponse(«restResource.fqn()»Reactive.class, lResponse)
                    );
                «ELSE»
                    ;
                «ENDIF»         
            «ELSE»
                ;
            «ENDIF» 
	      «ENDIF»
	  «ELSE»
		  «IF generateRESTRequestValidation() && this.getInputParameters().select(e|e.isParameterSuppressed() == false).isEmpty == false»
	        // Validate request parameter(s).
		    validationExecutor.validateRequest(«restResource.fqn()».class, «this.asParameterListNames()»);
		  «ENDIF»
		  
	      // Delegate request to service.
		  «IF getReturnTypeName() != "void"»
		       «IF generateRESTResponseValidation()»
		         «getReturnTypeName()» lResponse = «restResource.name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
			     
			     // Validate response and return it.
			     validationExecutor.validateResponse(«restResource.fqn()».class, lResponse);
			     return lResponse;
		       «ELSE»
	             return «restResource.name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
		       «ENDIF»
		  «ELSE»
		  «restResource.name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
		  «ENDIF»
	  «ENDIF»
	}
«ENDDEFINE»

«DEFINE AsyncJAXRSOperationImpl(JMM::RESTResource restResource) FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	«IF this.getRESTOperationPath(restResource).length > 0»@«getEnterpriseJavaPackage()».ws.rs.Path("«this.getRESTOperationPath(restResource)»")«ENDIF»
	«EXPAND HTTPMethods»
	«IF consumes.size > 0»@«getEnterpriseJavaPackage()».ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»«getEnterpriseJavaPackage()».ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@«getEnterpriseJavaPackage()».ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»«getEnterpriseJavaPackage()».ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
	«EXPAND java::Helper::GenerateAnnotations -»
	«EXPAND java::Helper::GenerateAnnotations FOR this.getReturnResult()-»
	«EXPAND java::Helper::NotNullAnnotationForParameter("RESTResource") FOR this.getReturnResult()-»
	public void  «name» (@«getEnterpriseJavaPackage()».ws.rs.container.Suspended «getEnterpriseJavaPackage()».ws.rs.container.AsyncResponse pAsyncResponse, @«getEnterpriseJavaPackage()».ws.rs.core.Context «getEnterpriseJavaPackage()».servlet.http.HttpServletRequest pRequest «IF this.hasInputParameters()»,«ENDIF» «EXPAND RESTParameterSignature FOR this»)«getThrownExceptionsAsString()»{
	    // Lookup workload manager that takes care that the system will have an optimal throughput.
	    com.anaptecs.jeaf.workload.api.WorkloadManager lWorkloadManager = com.anaptecs.jeaf.workload.api.Workload.getWorkloadManager();
	
	    // Prepare meta information about the request.
	    String lEndpointURL = pRequest.getServletPath() + pRequest.getPathInfo();
	    com.anaptecs.jeaf.workload.api.rest.RESTRequestType lRequestInfo = new com.anaptecs.jeaf.workload.api.rest.RESTRequestType(lEndpointURL, pRequest.getMethod());

     	«IF isTargetRuntimeJEAF()»
     	// Lookup service that will be called later during async processing of the request
     	«this.getOwningClass().fqn()» lService = this.get«this.getOwningClass().name»();
     	«ENDIF»
     	
	    // Hand over current request to workload manager. Depending on its strategy and the current workload the request will be either be directly executed, first queued or rejected.
	    lWorkloadManager.execute(lRequestInfo, new com.anaptecs.jeaf.workload.api.rest.RESTWorkloadErrorHandler(pAsyncResponse), new Runnable() {
			@Override
			public void run( ) {
			    try {
					«IF this.hasDataTypeParameters()»
					// Convert basic type parameters into "real" objects.
						«FOREACH this.getDataTypeParameters() AS basicParam»
							«IF basicParam.type.isCompositeDataTypeForRESTResource()»
					    		«IF generatePublicObjectView()»
									«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
					    		«ELSE»
					    			«basicParam.type.fqn()» «basicParam.name» = this.deserializeCompositeDataType(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class);
					    		«ENDIF»
							«ELSE»
								«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().«basicParam.type.attribute().select(e|e.isStatic == false).first().asSetter()»(«basicParam.name»AsBasicType).build();
							«ENDIF»
					  	«ENDFOREACH»
					«ENDIF»
					«IF isTargetRuntimeJEAF()»
						«IF getReturnTypeName() != "void"»
						«getReturnTypeName()» lResult = lService.«this.name»(«this.asParameterListNames()»);
						«getEnterpriseJavaPackage()».ws.rs.core.Response lResponseObject = «getEnterpriseJavaPackage()».ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
						«ELSE»
						lService.«this.name»(«this.asParameterListNames()»);
						«getEnterpriseJavaPackage()».ws.rs.core.Response lResponseObject = «getEnterpriseJavaPackage()».ws.rs.core.Response.ok().status(«EXPAND StatusCode»).build();
						«ENDIF»
					«ENDIF»
					«IF isTargetRuntimeSpring()»
						«IF getReturnTypeName() != "void"»
						«getReturnTypeName()» lResult = «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
						«getEnterpriseJavaPackage()».ws.rs.core.Response lResponseObject = «getEnterpriseJavaPackage()».ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
						«ELSE»
						«this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
						«getEnterpriseJavaPackage()».ws.rs.core.Response lResponseObject = «getEnterpriseJavaPackage()».ws.rs.core.Response.ok().status(«EXPAND StatusCode»).build();
						«ENDIF»
					«ENDIF»

					// Due to the asynchronous processing of the requests, the response can not be returned as return value. Therefore we make use of the defined JAX-RS mechanisms.
					pAsyncResponse.resume(lResponseObject);
			    }
				// All kinds of exceptions have to be reported to the client. Due to the asynchronous processing we have to
				// catch them here and return them to the client via class AsyncResponse.
				catch (RuntimeException e) {
					pAsyncResponse.resume(e);
				}
			}
		});
	}
«ENDDEFINE»

«DEFINE StatusCode FOR RESTOperation»
	«getEnterpriseJavaPackage()».ws.rs.core.Response.Status.«getJAXRSStatusCodeName(this.getStatusCodeName())»
«ENDDEFINE»

«DEFINE HTTPMethods FOR RESTOperation»
	«FOREACH httpMethods AS method»@«getEnterpriseJavaPackage()».ws.rs.«method»«ENDFOREACH»
«ENDDEFINE»

«DEFINE RESTParameterSignature FOR Operation»
  «EXPAND RESTParameterDefinition FOREACH ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false) SEPARATOR ", "» 
«ENDDEFINE»

«DEFINE RESTParameterDefinition FOR Parameter»
  «IF this.isStereotypeApplied("PathParam") -»
  @«getEnterpriseJavaPackage()».ws.rs.PathParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("HeaderParam") -»
  @«getEnterpriseJavaPackage()».ws.rs.HeaderParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("QueryParam") -»
  @«getEnterpriseJavaPackage()».ws.rs.QueryParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("CookieParam") -»
  @«getEnterpriseJavaPackage()».ws.rs.CookieParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("BeanParam") -»
  @«getEnterpriseJavaPackage()».ws.rs.BeanParam 
  «ENDIF-»
  «IF this.type.isStereotypeApplied("BeanParam") -»
  @«getEnterpriseJavaPackage()».ws.rs.BeanParam
  «ENDIF-»
  «IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()»
  @«getEnterpriseJavaPackage()».ws.rs.DefaultValue("«this.getDefaultValueForEnum()»")
  «ENDIF»
  «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicType()»
  @«getEnterpriseJavaPackage()».ws.rs.DefaultValue("«this.getDefaultValueForBasicType()»")
  «ENDIF»

«EXPAND java::Helper::GenerateAnnotations»
«EXPAND java::Helper::NotNullAnnotationForParameter("RESTResource")»
	«IF this.type.isOpenAPIDataType() && this.isRequestBody() == false»
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String«IF this.isMultivalued()»[]«ENDIF» «this.name»AsBasicType
	  	«ELSE»
	  		«this.type.attribute().select(e|e.isStatic == false).first().fqn()»«IF this.isMultivalued()»[]«ENDIF» «this.name»AsBasicType
	  	«ENDIF»
	«ELSE»
	  	«this.getTypeName()» «this.name»
	«ENDIF»
«ENDDEFINE»

«DEFINE SpringRESTParameterSignature(boolean reactive) FOR Operation»
  «EXPAND SpringRESTParameterDefinition(reactive) FOREACH ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false) SEPARATOR ", "» 
«ENDDEFINE»

«DEFINE SpringRESTParameterDefinition(boolean reactive) FOR Parameter»
  «IF this.isPathParam() -»
  @org.springframework.web.bind.annotation.PathVariable(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()» «IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isHeaderParam() -»
  @org.springframework.web.bind.annotation.RequestHeader(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isQueryParam() -»
  @org.springframework.web.bind.annotation.RequestParam(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isCookieParam() -»
  @org.springframework.web.bind.annotation.CookieValue(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isBeanParam() -»
  	«EXPAND ProcessBeanParam FOR ((Class)this.type)»
  «ENDIF-»
  «IF this.isRequestBody() -»
  @org.springframework.web.bind.annotation.RequestBody(required = «this.isRequired()»)
  «ENDIF-»

  «EXPAND java::Helper::GenerateAnnotations»
  «IF this.isBeanParam() == false»
      «EXPAND java::Helper::NotNullAnnotationForParameter("RESTResource")»
	  «IF this.type.isOpenAPIDataType() && this.isRequestBody() == false»
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String«IF this.isMultivalued()»[]«ENDIF» «name»AsBasicType
	  	«ELSE»
  			«this.type.attribute().select(e|e.isStatic == false).first().fqn()»«IF this.isMultivalued()»[]«ENDIF» «name»AsBasicType
	  	«ENDIF»
	  «ELSE»
	  	«IF this.type.isAnyDateType()»
	  		«IF this.isRequestBody() && reactive»«getMonoTypeName()»<«ENDIF»
	  		String«IF this.isMultivalued()»[]«ENDIF»
	  		«IF this.isRequestBody() && reactive»>«ENDIF» 
	  		«name»AsBasicType
	  	«ELSE»
	  		«REM»byte[] are transfered as base64 encoded Strings«ENDREM»
	  		«IF type.isPrimitiveType() && type.isByteType() && this.isMultivalued()»
	  		   «IF this.isRequestBody() && reactive»«getMonoTypeName()»<«ENDIF»
	  		   String
	  		   «IF this.isRequestBody() && reactive»>«ENDIF» 
	  		   «name»AsString
	  		«ELSE»
	  		   «IF this.isRequestBody()»
	  		   «this.getTypeName().getReactiveAwareTypeName(reactive)» «name»
	  		   «ELSE»
               «this.getTypeName()» «name»
	  		   «ENDIF»
	  		«ENDIF»
	  	«ENDIF»
	  «ENDIF»
  «ENDIF»
«ENDDEFINE»

«DEFINE ProcessBeanParam FOR Class»
	«EXPAND SpringRESTBeanParameterDefinition FOREACH this.getAllAttributesFromHierarchy().select(e|e.isPropertySuppressed() == false) SEPARATOR ","»
«ENDDEFINE»

«DEFINE SpringRESTBeanParameterDefinition FOR Property»
  «IF this.isPathParamProperty() -»
  @org.springframework.web.bind.annotation.PathVariable(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()» «IF this.isJEAFEnumerationProperty() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isHeaderParamProperty() -»
  @org.springframework.web.bind.annotation.RequestHeader(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumerationProperty() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isQueryParamProperty() -»
  @org.springframework.web.bind.annotation.RequestParam(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumerationProperty() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isCookieParamProperty() -»
  @org.springframework.web.bind.annotation.CookieValue(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumerationProperty() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF (this.type.isBasicType() || this.type.isPrimitiveType()) && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»

  «EXPAND java::Helper::GenerateAnnotations»
  «EXPAND java::Helper::NotNullAnnotationForBeanParameter»
	  «IF this.type.isOpenAPIDataType() »
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String«IF this.isMultivalued()»[]«ENDIF» «this.asParameter()»AsBasicType
	  	«ELSE»
	  		«this.type.attribute().select(e|e.isStatic == false).first().fqn()»«IF this.isMultivalued()»[]«ENDIF» «this.asParameter()»AsBasicType
	  	«ENDIF»
	  «ELSE»
	  	«IF this.type.isAnyDateType()»
	  		String«IF this.isMultivalued()»[]«ENDIF» «this.asParameter()»AsBasicType
	  	«ELSE»
            «REM»byte[] are transfered as base64 encoded Strings«ENDREM»
            «IF type.isPrimitiveType() && type.isByteType() && this.isMultivalued()»
               String «this.asParameter()»
            «ELSE»
	  		   «this.fqn()» «this.asParameter()»
	  		«ENDIF»
	  	«ENDIF»
	  «ENDIF»
«ENDDEFINE»

